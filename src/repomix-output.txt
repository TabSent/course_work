This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-23T18:23:59.712Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
main/Main.java
model/Person.java
model/PersonFactory.java
model/Professor.java
model/Staff.java
model/Student.java
repository/PersonDAO.java
service/Directory.java
service/DirectoryObserver.java
service/DirectoryUpdater.java
service/SearchStrategy.java
ui/DirectoryApp.java

================================================================
Repository Files
================================================================

================
File: main/Main.java
================
package main;

import model.Person;
import model.PersonFactory;
import repository.PersonDAO;
import service.Directory;
import ui.DirectoryApp;

import java.util.List;
import java.util.concurrent.Future;

public class Main {
    public static void main(String[] args) {
        Directory directory = Directory.getInstance();
        PersonDAO dao = new PersonDAO("persons.db");

        try {
            // Асинхронная загрузка данных
            Future<List<Person>> futurePersons = dao.loadPersonsAsync();
            directory.getPersons().addAll(futurePersons.get()); // Блокируем до завершения чтения

            // Добавление примеров (если требуется)
            if (directory.getPersons().isEmpty()) {
                addSampleData(directory);
                dao.savePersonsAsync(directory.getPersons()).get(); // Асинхронная запись
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            dao.shutdown();
        }

        // Запуск графического интерфейса
        DirectoryApp.main(args);
    }

    private static void addSampleData(Directory directory) {
        directory.getPersons().addAll(List.of(
                PersonFactory.createPerson("student", "Иван Иванов", "Студент 1 курса"),
                PersonFactory.createPerson("professor", "Олег Григорьев", "Профессор")
        ));
    }
}

================
File: model/Person.java
================
// src/model/Person.java
package model;

import java.io.Serializable;

public abstract class Person implements Serializable {
    private String name;
    private String position;

    public Person(String name, String position) {
        this.name = name;
        this.position = position;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    @Override
    public String toString() {
        return String.format("%s (%s)", name, position);
    }
}

================
File: model/PersonFactory.java
================
// src/model/PersonFactory.java
package model;

public class PersonFactory {
    public static Person createPerson(String type, String name, String position) {
        return switch (type.toLowerCase()) {
            case "student" -> new Student(name, position);
            case "staff" -> new Staff(name, position);
            case "professor" -> new Professor(name, position);
            default -> throw new IllegalArgumentException("Unknown person type: " + type);
        };
    }
}

================
File: model/Professor.java
================
// src/model/Professor.java
package model;

public class Professor extends Person {
    public Professor(String name, String position) {
        super(name, position);
    }
}

================
File: model/Staff.java
================
// src/model/Staff.java
package model;

public class Staff extends Person {
    public Staff(String name, String position) {
        super(name, position);
    }
}

================
File: model/Student.java
================
// src/model/Student.java
package model;

public class Student extends Person {
    public Student(String name, String position) {
        super(name, position);
    }
}

================
File: repository/PersonDAO.java
================
package repository;

import model.Person;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class PersonDAO {
    private final String filePath;
    private final ExecutorService executorService;

    public PersonDAO(String filePath) {
        this.filePath = filePath;
        this.executorService = Executors.newSingleThreadExecutor();
    }

    public CompletableFuture<List<Person>> loadPersonsAsync() {
        return CompletableFuture.supplyAsync(() -> {
            try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
                return (List<Person>) ois.readObject();
            } catch (FileNotFoundException e) {
                return new ArrayList<>(); // Если файла нет, возвращаем пустой список
            } catch (IOException | ClassNotFoundException e) {
                throw new RuntimeException("Ошибка при чтении файла", e);
            }
        });
    }

    public CompletableFuture<Void> savePersonsAsync(List<Person> persons) {
        return CompletableFuture.runAsync(() -> {
            try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
                oos.writeObject(persons);
            } catch (IOException e) {
                throw new RuntimeException("Ошибка при записи файла", e);
            }
        });
    }


    public void shutdown() {
        executorService.shutdown();
    }
}

================
File: service/Directory.java
================
package service;

import model.Person;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.ArrayList;

public class Directory {
    private static Directory instance;
    private final List<Person> persons;
    private final List<Runnable> observers = new ArrayList<>(); // Список наблюдателей

    private Directory() {
        this.persons = new CopyOnWriteArrayList<>();
    }

    public static synchronized Directory getInstance() {
        if (instance == null) {
            instance = new Directory();
        }
        return instance;
    }

    public List<Person> getPersons() {
        return persons;
    }

    public void addPerson(Person person) {
        persons.add(person);
        notifyObservers(); // Уведомление наблюдателей
    }

    public void removePerson(Person person) {
        persons.remove(person);
        notifyObservers(); // Уведомление наблюдателей
    }

    // Методы управления наблюдателями
    public void addObserver(Runnable observer) {
        observers.add(observer);
    }

    public void removeObserver(Runnable observer) {
        observers.remove(observer);
    }

    private void notifyObservers() {
        for (Runnable observer : observers) {
            observer.run();
        }
    }
}

================
File: service/DirectoryObserver.java
================
// src/service/DirectoryObserver.java
package service;

import java.util.ArrayList;
import java.util.List;

public class DirectoryObserver {
    private final List<Runnable> listeners = new ArrayList<>();

    public void addListener(Runnable listener) {
        listeners.add(listener);
    }

    public void notifyListeners() {
        listeners.forEach(Runnable::run);
    }
}

================
File: service/DirectoryUpdater.java
================
// src/service/DirectoryUpdater.java
package service;

import model.Person;

public class DirectoryUpdater implements Runnable {
    private final Directory directory;
    private final Person person;

    public DirectoryUpdater(Directory directory, Person person) {
        this.directory = directory;
        this.person = person;
    }

    @Override
    public void run() {
        directory.addPerson(person);
        System.out.println("Added: " + person);
    }
}

================
File: service/SearchStrategy.java
================
// src/service/SearchStrategy.java
package service;

import model.Person;

import java.util.List;
import java.util.stream.Collectors;

public interface SearchStrategy {
    List<Person> search(List<Person> persons, String query);
}

// Example Strategy Implementation
class NameSearchStrategy implements SearchStrategy {
    @Override
    public List<Person> search(List<Person> persons, String query) {
        return persons.stream()
                .filter(person -> person.getName().toLowerCase().contains(query.toLowerCase()))
                .collect(Collectors.toList());
    }
}

================
File: ui/DirectoryApp.java
================
// src/ui/DirectoryApp.java
package ui;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import model.Person;
import model.PersonFactory;
import service.Directory;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public class DirectoryApp extends Application {
    private final Directory directory = Directory.getInstance();
    private final ListView<String> personListView = new ListView<>();

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Электронный справочник кафедры");

        BorderPane root = new BorderPane();
        VBox leftPanel = createLeftPanel();
        VBox rightPanel = createRightPanel();

        root.setLeft(leftPanel);
        root.setCenter(rightPanel);

        Scene scene = new Scene(root, 1000, 600);
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    private VBox createLeftPanel() {
        VBox panel = new VBox(10);
        panel.setPadding(new Insets(10));
        panel.setStyle("-fx-background-color: #f0f0f0;");

        TextField nameField = new TextField();
        nameField.setPromptText("Имя");

        TextField positionField = new TextField();
        positionField.setPromptText("Должность");

        ComboBox<String> typeBox = new ComboBox<>();
        typeBox.getItems().addAll("Student", "Staff", "Professor");
        typeBox.setPromptText("Тип");

        Button addButton = new Button("Добавить");
        addButton.setOnAction(e -> addPerson(nameField, positionField, typeBox));

        panel.getChildren().addAll(
                new Label("Добавить пользователя"),
                nameField,
                positionField,
                typeBox,
                addButton
        );

        return panel;
    }

    private VBox createRightPanel() {
        VBox panel = new VBox(10);
        panel.setPadding(new Insets(10));

        TextField searchField = new TextField();
        searchField.setPromptText("Поиск по имени");

        Button searchButton = new Button("Найти");
        searchButton.setOnAction(e -> searchByName(searchField));

        Button deleteButton = new Button("Удалить");
        deleteButton.setOnAction(e -> deletePersonWithConfirmation());

        Button editButton = new Button("Редактировать");
        editButton.setOnAction(e -> editPerson());

        // Горизонтальный ряд кнопок
        HBox actionButtons = new HBox(10);
        actionButtons.getChildren().addAll(searchButton, deleteButton, editButton);

        ComboBox<String> typeFilterBox = new ComboBox<>();
        typeFilterBox.getItems().addAll("All", "Student", "Staff", "Professor");
        typeFilterBox.setValue("All");

        ComboBox<String> sortTypeBox = new ComboBox<>();
        sortTypeBox.getItems().addAll("None", "By Name", "By Type");
        sortTypeBox.setValue("None");

        Button filterSortButton = new Button("Применить фильтр и сортировку");
        filterSortButton.setOnAction(e -> searchAndSortPersons(searchField, typeFilterBox, sortTypeBox));

        personListView.setPrefHeight(500);
        refreshList();

        panel.getChildren().addAll(
                new Label("Список пользователей"),
                personListView,
                new Label("Поиск"),
                searchField,
                actionButtons, // Добавили кнопки в один ряд
                new Label("Фильтрация"),
                typeFilterBox,
                new Label("Сортировка"),
                sortTypeBox,
                filterSortButton
        );

        return panel;
    }

    private void addPerson(TextField nameField, TextField positionField, ComboBox<String> typeBox) {
        String name = nameField.getText();
        String position = positionField.getText();
        String type = typeBox.getValue();

        if (name.isEmpty() || position.isEmpty() || type == null) {
            showAlert("Ошибка", "Все поля должны быть заполнены.", Alert.AlertType.ERROR);
            return;
        }

        try {
            Person person = PersonFactory.createPerson(type.toLowerCase(), name, position);
            directory.addPerson(person);
            refreshList();
            showAlert("Успех", "Пользователь успешно добавлен.", Alert.AlertType.INFORMATION);
            nameField.clear();
            positionField.clear();
            typeBox.setValue(null);
        } catch (IllegalArgumentException e) {
            showAlert("Ошибка", e.getMessage(), Alert.AlertType.ERROR);
        }
    }

    private void refreshList() {
        personListView.getItems().setAll(directory.getPersons().stream()
                .map(Person::toString)
                .collect(Collectors.toList()));
    }

    private void searchByName(TextField searchField) {
        String query = searchField.getText().toLowerCase();

        List<Person> filteredPersons = directory.getPersons().stream()
                .filter(person -> person.getName().toLowerCase().contains(query))
                .collect(Collectors.toList());

        personListView.getItems().setAll(filteredPersons.stream()
                .map(Person::toString)
                .collect(Collectors.toList()));
    }

    private void searchAndSortPersons(TextField searchField, ComboBox<String> typeFilterBox, ComboBox<String> sortTypeBox) {
        String query = searchField.getText().toLowerCase();
        String typeFilter = typeFilterBox.getValue();
        String sortType = sortTypeBox.getValue();

        List<Person> filteredPersons = directory.getPersons();

        if (!query.isEmpty()) {
            filteredPersons = filteredPersons.stream()
                    .filter(person -> person.getName().toLowerCase().contains(query))
                    .collect(Collectors.toList());
        }

        if (!typeFilter.equals("All")) {
            filteredPersons = filteredPersons.stream()
                    .filter(person -> person.getClass().getSimpleName().equalsIgnoreCase(typeFilter))
                    .collect(Collectors.toList());
        }

        switch (sortType) {
            case "By Name" -> filteredPersons.sort(Comparator.comparing(Person::getName));
            case "By Type" -> filteredPersons.sort(Comparator.comparing(person -> person.getClass().getSimpleName()));
        }

        personListView.getItems().setAll(filteredPersons.stream()
                .map(Person::toString)
                .collect(Collectors.toList()));
    }

    private void deletePersonWithConfirmation() {
        String selectedPerson = personListView.getSelectionModel().getSelectedItem();

        if (selectedPerson == null) {
            showAlert("Ошибка", "Выберите пользователя для удаления.", Alert.AlertType.ERROR);
            return;
        }

        Alert confirmationAlert = new Alert(Alert.AlertType.CONFIRMATION);
        confirmationAlert.setTitle("Подтверждение удаления");
        confirmationAlert.setHeaderText("Вы уверены, что хотите удалить?");
        confirmationAlert.setContentText(selectedPerson);

        if (confirmationAlert.showAndWait().orElse(ButtonType.CANCEL) == ButtonType.OK) {
            directory.getPersons().removeIf(person -> person.toString().equals(selectedPerson));
            refreshList();
            showAlert("Успех", "Пользователь успешно удалён.", Alert.AlertType.INFORMATION);
        }
    }

    private void editPerson() {
        String selectedPerson = personListView.getSelectionModel().getSelectedItem();

        if (selectedPerson == null) {
            showAlert("Ошибка", "Выберите пользователя для редактирования.", Alert.AlertType.ERROR);
            return;
        }

        Person person = directory.getPersons().stream()
                .filter(p -> p.toString().equals(selectedPerson))
                .findFirst()
                .orElse(null);

        if (person == null) {
            showAlert("Ошибка", "Пользователь не найден.", Alert.AlertType.ERROR);
            return;
        }

        TextInputDialog dialog = new TextInputDialog(person.getName());
        dialog.setTitle("Редактирование");
        dialog.setHeaderText("Редактировать имя пользователя");
        dialog.setContentText("Новое имя:");

        dialog.showAndWait().ifPresent(newName -> {
            person.setName(newName);
            refreshList();
            showAlert("Успех", "Пользователь успешно обновлён.", Alert.AlertType.INFORMATION);
        });
    }

    private void showAlert(String title, String message, Alert.AlertType type) {
        Alert alert = new Alert(type);
        alert.setTitle(title);
        alert.setContentText(message);
        alert.showAndWait();
    }
}
